{
  parserClass="net.stefanfuchs.jslt.intellij.language.parser.JsltParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Jslt"
  psiImplClassSuffix="Impl"
  psiPackage="net.stefanfuchs.jslt.intellij.language.psi"
  psiImplPackage="net.stefanfuchs.jslt.intellij.language.psi.impl"

  elementTypeHolderClass="net.stefanfuchs.jslt.intellij.language.psi.JsltTypes"
  elementTypeClass="net.stefanfuchs.jslt.intellij.language.psi.JsltElementType"
  tokenTypeClass="net.stefanfuchs.jslt.intellij.language.psi.JsltTokenType"

  psiImplUtilClass="net.stefanfuchs.jslt.intellij.language.psi.impl.JsltPsiImplUtil"
}

jsltFile ::= {
    COMMENT*
    ImportDeclarations?
    (LetAssignment | FunctionDecl)*
    Expr <<eof>>
}

Expr ::= OrExpr (PipeOperator OrExpr)*
OrExpr ::= AndExpr (OR OrExpr)?
AndExpr ::= ComparativeExpr (AND AndExpr())?
ComparativeExpr ::= AdditiveExpr (Comparator AdditiveExpr)?
Comparator ::=  EQUALS | UNEQUALS | BIGOREQ | BIGGER | SMALLER | SMALLOREQ
PipeOperator ::= PIPE
AdditiveExpr ::= MultiplicativeExpr (AdditiveOperator MultiplicativeExpr)*
AdditiveOperator ::= PLUS | MINUS
MultiplicativeExpr ::= BaseExpr (MultiplicativeOperator BaseExpr)*
MultiplicativeOperator ::= STAR | SLASH
BaseExpr ::= {
                NULL | INTEGER | DECIMAL | STRING | TRUE | FALSE |
                Chainable | ParenthesisExpr | IfStatement |
                Array |
                (Object | ObjectComprehension)
             }
Chainable ::= {
                (FunctionCall | VARIABLE | DOT (IDENT | STRING)?)
                (ChainLink)?
              }
ChainLink ::= {
                (DotKey | ArraySlicing)
                (ChainLink)?
              }
ParenthesisExpr ::= LPAREN Expr RPAREN
DotKey ::= DOT (IDENT | STRING)
ArraySlicingBody ::= Expr (ColonExpr Expr?)? | ColonExpr Expr
ArraySlicing ::= LBRACKET ArraySlicingBody RBRACKET
ColonExpr ::= COLON
ArrayElements ::= Expr (COMMA Expr)*
ArrayBody ::=(FOR ParenthesisExpr ArrayForBody) | ArrayElements? {methods=[ getExpressions ]}
ArrayForBody ::= LetAssignment* Expr (IF ParenthesisExpr)?
Array ::= LBRACKET ArrayBody RBRACKET {methods=[ getPresentation ]}
ObjectBody ::= LetAssignment* (Pairs | Matcher)?
Object ::= LCURLY ObjectBody RCURLY {methods=[ getPresentation ]}
Matcher ::= STAR MatcherMinus? COLON Expr {methods=[ getPresentation ]}
MatcherMinus ::= MINUS (IDENT | STRING) (COMMA (IDENT | STRING))*
Pair ::= Expr COLON Expr {methods=[ getName getPresentation ]}
Pairs ::= {
               Pair
               (COMMA Pair)*
               (COMMA Matcher)?
          }
ObjectComprehensionBody ::= FOR ParenthesisExpr ObjectComprehensionForBody
ObjectComprehensionForBody ::= LetAssignment* Pair (IF ParenthesisExpr)?
ObjectComprehension ::= LCURLY ObjectComprehensionBody RCURLY  {methods=[ getPresentation ]}
FunctionBody ::= LetAssignment* Expr
IfStatement ::= {
                  IF ParenthesisExpr
                    FunctionBody
                  ElseBranch?
                }
ElseBranch ::= ELSE FunctionBody
FunctionName ::= (IDENT | PIDENT)
FunctionCall ::= FunctionName LPAREN (Expr (COMMA Expr)*)? RPAREN
LetAssignment ::= LET VARIABLE_DECL ASSIGN Expr  {methods=[ getName getPresentation ]}
FunctionDecl ::= {
                   DEF FUNCTION_DECL_NAME LPAREN (FUNCTION_DECL_PARAM (COMMA FUNCTION_DECL_PARAM)*)? RPAREN
                     FunctionBody
                 } {methods=[ getName getPresentation getLetAssignmentList getExpr ]}
ImportDeclarations ::= ImportDeclaration*
ImportDeclaration ::= IMPORT STRING AS IDENT  {methods=[ getName getPresentation ]}